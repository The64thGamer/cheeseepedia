{{- /*
Partial: site_search.html
Usage:
{{ partial "site_search.html" . }}

Notes:
- Loads search JSON data from /data/*.json via fetch.
*/ -}}

{{- $dictionary := dict
"Animatronic Preservation" "<img src=\"/UI/Emojis/wrench.svg\" class=\"emoji\">"
"Animatronic Shows" "<img src=\"/UI/Emojis/bang.svg\" class=\"emoji\">"
"Animatronics" "<img src=\"/UI/Emojis/spiky_speech_bubble.svg\" class=\"emoji\">"
"Costumed Characters" "<img src=\"/UI/Emojis/back_of_hand_hoof_d1.svg\" class=\"emoji\">"
"Animatronic Parts" "<img src=\"/UI/Emojis/factory.svg\" class=\"emoji\">"
"Retrofits" "<img src=\"/UI/Emojis/pirate_flag.svg\" class=\"emoji\">"
"Stage Variations" "<img src=\"/UI/Emojis/speaker.svg\" class=\"emoji\">"
"Corporate Documents" "<img src=\"/UI/Emojis/page_with_pencil.svg\" class=\"emoji\">"
"Social Media and Websites" "<img src=\"/UI/Emojis/globe.svg\" class=\"emoji\">"
"Documents" "<img src=\"/UI/Emojis/page.svg\" class=\"emoji\">"
"Promotional Material" "<img src=\"/UI/Emojis/curled_page.svg\" class=\"emoji\">"
"Animatronic Control Systems" "<img src=\"/UI/Emojis/control_knobs.svg\" class=\"emoji\">"
"Other Systems" "<img src=\"/UI/Emojis/crt_test_pattern.svg\" class=\"emoji\">"
"Simulators" "<img src=\"/UI/Emojis/crt_noise.svg\" class=\"emoji\">"
"Programming Systems" "<img src=\"/UI/Emojis/crt_prompt.svg\" class=\"emoji\">"
"Characters" "<img src=\"/UI/Emojis/thumbs_up_paw.svg\" class=\"emoji\">"
"Events" "<img src=\"/UI/Emojis/tada.svg\" class=\"emoji\">"
"History" "<img src=\"/UI/Emojis/spider_web.svg\" class=\"emoji\">"
"Ad Vehicles" "<img src=\"/UI/Emojis/bus.svg\" class=\"emoji\">"
"Arcades and Attractions" "<img src=\"/UI/Emojis/arcade_stick.svg\" class=\"emoji\">"
"Employee Wear" "<img src=\"/UI/Emojis/chef_v1.svg\" class=\"emoji\">"
"Locations" "<img src=\"/UI/Emojis/world_map.svg\" class=\"emoji\">"
"Cancelled Locations" "<img src=\"/UI/Emojis/bomb.svg\" class=\"emoji\">"
"Remodels and Initiatives" "<img src=\"/UI/Emojis/construction_sign.svg\" class=\"emoji\">"
"Store Fixtures" "<img src=\"/UI/Emojis/package.svg\" class=\"emoji\">"
"Commercials" "<img src=\"/UI/Emojis/movie_camera.svg\" class=\"emoji\">"
"News Footage" "<img src=\"/UI/Emojis/tv.svg\" class=\"emoji\">"
"Photos" "<img src=\"/UI/Emojis/camera_with_flash.svg\" class=\"emoji\">"
"Videos" "<img src=\"/UI/Emojis/film_frames.svg\" class=\"emoji\">"
"Company Media" "<img src=\"/UI/Emojis/dvd.svg\" class=\"emoji\">"
"In-Store Merchandise" "<img src=\"/UI/Emojis/free.svg\" class=\"emoji\">"
"Products" "<img src=\"/UI/Emojis/dollar.svg\" class=\"emoji\">"
"Menu Items" "<img src=\"/UI/Emojis/pizza.svg\" class=\"emoji\">"
"ShowBiz Pizza Place" "<img src=\"/UI/Emojis/pizza.svg\" class=\"emoji\">"
"Pizza Time Theatre" "<img src=\"/UI/Emojis/pizza.svg\" class=\"emoji\">"
"Chuck E. Cheese's" "<img src=\"/UI/Emojis/pizza.svg\" class=\"emoji\">"
"Movies" "<img src=\"/UI/Emojis/cinema.svg\" class=\"emoji\">"
"Tickets" "<img src=\"/UI/Emojis/cross.svg\" class=\"emoji\">"
"Tokens" "<img src=\"/UI/Emojis/cross.svg\" class=\"emoji\">"
"Video Games" "<img src=\"/UI/Emojis/gamepad.svg\" class=\"emoji\">"
"Family Vision" "<img src=\"/UI/Emojis/projector.svg\" class=\"emoji\">"
"Live Shows" "<img src=\"/UI/Emojis/music_note.svg\" class=\"emoji\">"
"ShowBiz Pizza Programs" "<img src=\"/UI/Emojis/cassette.svg\" class=\"emoji\">"
"Showtape Formats" "<img src=\"/UI/Emojis/vhs.svg\" class=\"emoji\">"
"Puppets" "<img src=\"/UI/Emojis/back_of_hand_paw_k2.svg\" class=\"emoji\">"
"Showtapes" "<img src=\"/UI/Emojis/music_notes.svg\" class=\"emoji\">"
"Animatronic News" "<img src=\"/UI/Emojis/decreasing_graph.svg\" class=\"emoji\">"
"Meta" "<img src=\"/UI/Emojis/zzz.svg\" class=\"emoji\">"
"Reviews" "<img src=\"/UI/Emojis/fire.svg\" class=\"emoji\">"
"Transcriptions" "<img src=\"/UI/Emojis/pencil.svg\" class=\"emoji\">"
"User" "<img src=\"/UI/Emojis/furry_pride.svg\" class=\"emoji\">"
"Restaurants/FECs" "<img src=\"/UI/Emojis/plate.svg\" class=\"emoji\">"
-}}


<div class="search-ui-container">
  <div class="search-controls">
    <div class="search-tags-wrapper">
      <div id="tag-chip-container" class="tag-chip-container" tabindex="0">
        <input id="tag-input" class="tag-input" placeholder="Search Tags" autocomplete="off" />
      </div>
      <div id="tag-suggestions" class="tag-suggestions" aria-hidden="true"></div>
    </div>
    <div class="search-fuzzy-wrapper">
      <input id="fuzzy-q" class="search-fuzzy" placeholder="Search Text Contents" autocomplete="off" />
    </div>
  </div>

  <div class="search-layout">
    <aside class="search-left-col">
      <div class="predef-list">
        {{- $predef := slice
        "Pizza Time Theatre"
        "ShowBiz Pizza Place"
        "Chuck E. Cheese's"
        "Locations"
        "Showtapes"
        "Animatronic Shows"
        "Stage Variations"
        "Animatronics"
        "History"
        "Cancelled Locations"
        "Remodels and Initiatives"
        "Store Fixtures"
        "Restaurants/FECs"
        "Characters"
        "Costumed Characters"
        "Puppets"
        "Live Shows"
        "Events"
        "Animatronic Parts"
        "Animatronic Control Systems"
        "Animatronic Preservation"
        "Retrofits"
        "Other Systems"
        "Simulators"
        "Programming Systems"
        "Photos"
        "Videos"
        "Commercials"
        "News Footage"
        "Company Media"
        "Movies"
        "ShowBiz Pizza Programs"
        "Showtape Formats"
        "Arcades and Attractions"
        "Video Games"
        "Family Vision"
        "Corporate Documents"
        "Documents"
        "Promotional Material"
        "Social Media and Websites"
        "Ad Vehicles"
        "In-Store Merchandise"
        "Products"
        "Menu Items"
        "Tickets"
        "Tokens"
        "Employee Wear"
        "Reviews"
        "Transcriptions"
        "User"
        "Meta"
        -}}
        <div class="predef-tags">
          <h4>Quick Tags</h4>
          <div class="predef-scroll">
            <div class="predef-list">
              {{- range $i, $t := $predef -}}
              {{- $emoji := index $dictionary $t -}}
              <button class="predef-tag-btn" type="button" data-tag="{{ $t | html }}" title="Add tag">
                {{ if $emoji }}{{ $emoji | safeHTML }} {{ end }}{{ $t }}
              </button>
              {{- end -}}
            </div>
          </div>
        </div>
      </div>
    </aside>
    <div class="tabs" id="results-tabs">
      <div class="tab-buttons">
        <button class="tab-button active" data-tab="tab-articles">Articles</button>
        <button class="tab-button" data-tab="tab-photos">Photos</button>
        <button class="tab-button" data-tab="tab-videos">Videos</button>
        <button class="tab-button" data-tab="tab-reviews">Reviews</button>
      </div>

      <div class="tab-content">
        <div class="tab-panel active" id="tab-articles">
          <div class="results-summary" aria-live="polite"></div>
          <div class="results-list" id="list-articles"></div>
        </div>

        <div class="tab-panel" id="tab-photos">
          <div class="results-list" id="list-photos"></div>
        </div>

        <div class="tab-panel" id="tab-videos">
          <div class="results-list" id="list-videos"></div>
        </div>

        <div class="tab-panel" id="tab-reviews">
          <div class="results-list" id="list-reviews"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    // --- DATA STORAGE ---
    let DOCS = [], TAGS_BY_PAGE = {}, PAGES_BY_TAG = {}, TAG_COUNTS = {}, ALL_TAGS = [];
    const DOC_TAGS = {}; // map of page path -> [tags]
    const SEARCH_TABS = ["tab-articles", "tab-photos", "tab-videos", "tab-reviews"];
    let activeTags = [];
    let searchTimer = null;

    // --- DOM ELEMENTS ---

    const tabButtons = Array.from(document.querySelectorAll(".tab-button"));
    const fuzzyInput = document.getElementById("fuzzy-q");
    const tagInput = document.getElementById("tag-input");
    const tagChipContainer = document.getElementById("tag-chip-container");
    const tagSuggestions = document.getElementById("tag-suggestions");
    const listArticles = document.getElementById("list-articles");
    const listPhotos = document.getElementById("list-photos");
    const listVideos = document.getElementById("list-videos");
    const listReviews = document.getElementById("list-reviews");
    const predefButtons = document.querySelectorAll(".predef-tag-btn");

    // --- UTILITY FUNCTIONS ---
    const reNonWord = /[^\w\s]/g, reSpace = /\s+/g;

    function normalizeText(s) {
      if (!s) return "";
      return String(s).toLowerCase().replace(reNonWord, " ").replace(reSpace, " ").trim();
    }

    function tokenize(s) {
      if (!s) return [];
      return normalizeText(s).split(/\s+/).filter(Boolean);
    }

    function charTrigrams(s) {
      s = "  " + normalizeText(s) + "  ";
      const out = new Set();
      for (let i = 0; i + 3 <= s.length; i++) out.add(s.slice(i, i + 3));
      return out;
    }

    function jaccard(a, b) {
      if (!a.size || !b.size) return 0;
      let inter = 0;
      for (const x of a) if (b.has(x)) inter++;
      return inter / (a.size + b.size - inter);
    }

    function escapeHtml(s) {
      if (!s) return "";
      return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
    }

    // --- FETCH AND INITIALIZE DATA ---
    async function loadSearchData() {
      const [docsRes, tagsRes, pagsRes, countsRes] = await Promise.all([
        fetch("/data/search/docs.json"),
        fetch("/data/tags/tags_by_page.json"),
        fetch("/data/tags/pages_by_tag.json"),
        fetch("/data/tags/tag_counts.json")
      ]);
      DOCS = await docsRes.json();
      TAGS_BY_PAGE = await tagsRes.json();
      TAG_COUNTS = await countsRes.json();
      PAGES_BY_TAG = await pagsRes.json();

      ALL_TAGS = Object.keys(TAG_COUNTS || {}).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

      // preprocess docs for tokens/trigrams
      DOCS.forEach(doc => {
        const text = [doc.title || "", doc.excerpt || "", doc.content || "", doc.summary || ""].join(" ");
        doc.tokens = doc.tokens || Array.from(new Set(tokenize(text)));
        doc.trigrams = doc.trigrams || Array.from(charTrigrams(text));
        if (doc.path && doc.path.startsWith("/")) doc.path = doc.path.slice(1);
      });

      console.log("Search data loaded", { DOCS, TAGS_BY_PAGE, PAGES_BY_TAG, TAG_COUNTS, ALL_TAGS });
    }

    // --- TAG HANDLING ---
    function addTag(tagStr, negative = false) {
      if (!tagStr) return;
      const found = ALL_TAGS.find(t => t.toLowerCase() === tagStr.toLowerCase());
      const canon = found || tagStr;
      const idx = activeTags.findIndex(t => t.tag.toLowerCase() === canon.toLowerCase() && t.negative === negative);
      if (idx !== -1) return;
      const opp = activeTags.findIndex(t => t.tag.toLowerCase() === canon.toLowerCase() && t.negative !== negative);
      if (opp !== -1) activeTags.splice(opp, 1);
      activeTags.push({ tag: canon, negative });
      renderTagChips();
    }

    function renderTagChips() {
      Array.from(tagChipContainer.querySelectorAll(".tag-chip")).forEach(n => n.remove());
      activeTags.forEach((t, i) => {
        const chip = document.createElement("span");
        chip.className = "tag-chip " + (t.negative ? "tag-chip-neg" : "tag-chip-pos");
        chip.setAttribute("data-tag", t.tag);
        chip.innerHTML = `<button class="tag-chip-close" aria-label="Remove tag" data-idx="${i}">âœ•</button><span class="tag-chip-label">${t.negative ? '-' : ''}${escapeHtml(t.tag)}</span>`;
        tagChipContainer.insertBefore(chip, tagInput);
      });
      tagInput.value = "";
      tagInput.focus();
      scheduleSearch();
    }

    tagChipContainer.addEventListener("click", e => {
      const btn = e.target.closest(".tag-chip-close");
      if (!btn) return;
      const idx = Number(btn.dataset.idx);
      if (!Number.isNaN(idx)) {
        activeTags.splice(idx, 1);
        renderTagChips();
      }
    });

    predefButtons.forEach(b => {
      b.addEventListener("click", function () { addTag(this.dataset.tag, false); });
    });

    // --- TAG SUGGESTIONS ---
    let suggestionIndex = -1;
    function suggestTags(prefix, limit = 10) {
      if (!prefix) return [];

      let isNeg = false;
      if (prefix.startsWith("-")) {
        isNeg = true;
        prefix = prefix.slice(1).trim();
      }

      const q = normalizeText(prefix);
      if (!q) return [];

      // Only use ALL_TAGS (from TAG_COUNTS)
      const matches = ALL_TAGS
        .map(tag => ({
          tag,
          count: TAG_COUNTS[tag] || 0,
          negative: isNeg
        }))
        .filter(t => normalizeText(t.tag).includes(q))  // partial match
        .sort((a, b) => {
          // Sort by count descending, then alphabetical
          if (b.count !== a.count) return b.count - a.count;
          return a.tag.localeCompare(b.tag);
        })
        .slice(0, limit);

      return matches;
    }

    function showSuggestions(list) {
      tagSuggestions.innerHTML = ""; // rebuild
      if (!list || !list.length) {
        tagSuggestions.style.display = "none";
        tagSuggestions.setAttribute("aria-hidden", "true");
        return;
      }

      tagSuggestions.style.display = "block";
      tagSuggestions.setAttribute("aria-hidden", "false");

      list.forEach((s, i) => {
        const el = document.createElement("div");
        el.className = "tag-suggestion";
        el.dataset.i = i;
        el.innerHTML = `<span class="suggest-tag">${s.negative ? "-" : ""}${escapeHtml(s.tag)}</span> <span class="suggest-count">(${s.count || 0})</span>`;
        el.addEventListener("mousedown", ev => {
          ev.preventDefault();
          addTag(s.tag, s.negative);
          hideSuggestions();
        });
        tagSuggestions.appendChild(el);
      });

      suggestionIndex = -1;
      tagSuggestions.scrollTop = 0; // <-- force scrollbar to top every time
    }

    function hideSuggestions() { tagSuggestions.innerHTML = ""; tagSuggestions.style.display = "none"; tagSuggestions.setAttribute("aria-hidden", "true"); }

    tagInput.addEventListener("input", () => {
      const v = tagInput.value || "";
      if (!v.trim()) { hideSuggestions(); return; }
      showSuggestions(suggestTags(v, 12));
    });

    tagInput.addEventListener("keydown", e => {
      const v = tagInput.value || "";
      const items = Array.from(tagSuggestions.querySelectorAll(".tag-suggestion"));
      if (e.key === "Enter") { e.preventDefault(); addTag(v.trim().startsWith("-") ? v.trim().slice(1) : v.trim(), v.trim().startsWith("-")); hideSuggestions(); }
      else if (e.key === "Tab") { if (items.length) { e.preventDefault(); const txt = items[0].querySelector(".suggest-tag").textContent; addTag(txt.startsWith("-") ? txt.slice(1) : txt, txt.startsWith("-")); hideSuggestions(); } }
      else if (e.key === "ArrowDown") { if (items.length) { e.preventDefault(); suggestionIndex = Math.min(suggestionIndex + 1, items.length - 1); items.forEach((it, i) => it.classList.toggle("active", i === suggestionIndex)); items[suggestionIndex].scrollIntoView({ block: "nearest" }); } }
      else if (e.key === "ArrowUp") { if (items.length) { e.preventDefault(); suggestionIndex = Math.max(suggestionIndex - 1, 0); items.forEach((it, i) => it.classList.toggle("active", i === suggestionIndex)); items[suggestionIndex].scrollIntoView({ block: "nearest" }); } }
      else if (e.key === "Escape") { hideSuggestions(); }
    });

    document.addEventListener("click", e => { if (!tagSuggestions.contains(e.target) && e.target !== tagInput) hideSuggestions(); });

    // --- SEARCH LOGIC ---
    function docHasTag(doc, tag) {
      const tags = TAGS_BY_PAGE[doc.path] || [];
      const want = tag.toLowerCase();
      return tags.some(t => String(t).toLowerCase() === want);
    }

    function scoreDocForQuery(doc, qTokens, qTris) {
      const docTris = new Set(doc.trigrams || []), docTokens = new Set(doc.tokens || []);
      let tJ = jaccard(qTris, docTris);
      let tokOverlap = 0;
      if (qTokens.length) { tokOverlap = qTokens.filter(t => docTokens.has(t)).length / qTokens.length; }
      let titleBoost = 0;
      const titleLower = (doc.title || "").toLowerCase();
      for (const t of qTokens) if (titleLower.includes(t)) { titleBoost = 0.12; break; }
      return 0.72 * tJ + 0.26 * tokOverlap + titleBoost;
    }

    function search(fuzzyQuery, tagFilters, maxResults = 500) {
      let results = [];

      const isFuzzyEmpty = !fuzzyQuery || !fuzzyQuery.trim();
      console.log("search called", { fuzzyQuery, tagFilters });
      const qTokens = isFuzzyEmpty ? [] : tokenize(fuzzyQuery);
      const qTris = isFuzzyEmpty ? new Set() : charTrigrams(fuzzyQuery);

      if (isFuzzyEmpty && tagFilters.length > 0) {
        // tag-only search
        console.log("tag-only branch");
        let candidatePaths = null;

        tagFilters.forEach(tf => {
          const tagKey = tf.tag; // exact casing from ALL_TAGS / TAG_COUNTS
          const pagesForTagObjs = PAGES_BY_TAG[tagKey] || [];
          const pagesForTag = pagesForTagObjs.map(p => p.path || p); // normalize to string paths
          console.log(`tag: ${tagKey}, pages:`, pagesForTag);

          if (tf.negative) {
            if (!candidatePaths) {
              candidatePaths = Object.values(PAGES_BY_TAG).flat().map(p => p.path || p);
            }
            candidatePaths = candidatePaths.filter(p => !pagesForTag.includes(p));
          } else {
            if (!candidatePaths) {
              candidatePaths = [...pagesForTag];
            } else {
              candidatePaths = candidatePaths.filter(p => pagesForTag.includes(p));
            }
          }
        });

        if (!candidatePaths) candidatePaths = [];
        console.log("candidatePaths:", candidatePaths);

        results = candidatePaths.map(p => {
          const doc = DOCS.find(d => d.path === p) || { path: p, title: p };
          return { score: 1, doc };
        });
      } else {
        // --- FUZZY SEARCH (with optional tags) ---
        for (const doc of DOCS) {
          // --- check tag filters ---
          let ok = true;
          for (const tf of tagFilters) {
            const want = tf.tag;
            if (tf.negative) {
              if (docHasTag(doc, want)) { ok = false; break; }
            } else {
              if (!docHasTag(doc, want)) { ok = false; break; }
            }
          }
          if (!ok) continue;

          // --- fuzzy scoring ---
          const score = scoreDocForQuery(doc, qTokens, qTris);
          if (score > 0) results.push({ score, doc });
        }
      }

      results.sort((a, b) => b.score - a.score);
      return results.slice(0, maxResults);
    }


    function scheduleSearch() { if (searchTimer) clearTimeout(searchTimer); searchTimer = setTimeout(executeSearch, 150); }
    fuzzyInput.addEventListener("input", scheduleSearch);
    fuzzyInput.addEventListener("keydown", e => { if (e.key === "Enter") { e.preventDefault(); executeSearch(); } });

    // --- RENDERING ---
function renderArticle(doc) {
  const fm = doc.frontmatter || {};

  const hasContent = !!(doc.content || doc.excerpt || doc.title);
  const wrapper = document.createElement("div");
  wrapper.className = hasContent ? "list-page-block" : "list-page-empty-block";

  // Helper: format date like your Hugo partial
  const formatDate = dateStr => {
    if (!dateStr || dateStr === "0000-00-00") return "?";
    const parts = dateStr.split(" ")[0].split("-");
    const year = parts[0] || "0000";
    const month = parts[1] || "00";
    const day = parts[2] || "00";

    const months = {
      "00": "", "01": "Jan. ", "02": "Feb. ", "03": "Mar. ", "04": "Apr. ",
      "05": "May ", "06": "Jun. ", "07": "Jul. ", "08": "Aug. ", "09": "Sep. ",
      "10": "Oct. ", "11": "Nov. ", "12": "Dec."
    };
    const days = {
      "00": "", "01": "1, ", "02": "2, ", "03": "3, ", "04": "4, ", "05": "5, ",
      "06": "6, ", "07": "7, ", "08": "8, ", "09": "9, ", "10": "10, ", "11": "11, ",
      "12": "12, ", "13": "13, ", "14": "14, ", "15": "15, ", "16": "16, ", "17": "17, ",
      "18": "18, ", "19": "19, ", "20": "20, ", "21": "21, ", "22": "22, ", "23": "23, ",
      "24": "24, ", "25": "25, ", "26": "26, ", "27": "27, ", "28": "28, ", "29": "29, ",
      "30": "30, ", "31": "31, "
    };
    return `${months[month]}${days[day]}${year !== "0000" ? year : ""}`;
  };

  const startDate = formatDate(fm.startDate);
  const endDate = formatDate(fm.endDate);

  // Use pageThumbnailFile if it exists, otherwise fallback image
  const imgSrc = fm.pageThumbnailFile ? `/photos/${fm.pageThumbnailFile}` : "/UI/File%20Not%20Found.jpg";

  wrapper.innerHTML = `
    <div class="list-page-container">
      <div class="list-image">
        <a href="${doc.path}">
          <img src="${imgSrc}" class="thumbnail" />
        </a>
      </div>

      <div class="list-page-content">
        <a href="${doc.path}">
          ${escapeHtml(fm.title || doc.title || doc.path)}
          ${fm.downloadLinks && fm.downloadLinks.length ? '<img src="/UI/Emojis/inbox.svg" class="emoji">' : ""}
        </a>
        <div class="list-page-date">
          ${startDate} - ${endDate}
        </div>
      </div>
    </div>
  `;

  return wrapper;
}

    function renderPhoto(doc) { const w = document.createElement("div"); w.className = "article-photo-block"; w.innerHTML = `<div>${escapeHtml(doc.title || "")}</div>`; return w; }
    function renderVideo(doc) { const w = document.createElement("div"); w.className = "list-page-block-video"; w.innerHTML = `<div>${escapeHtml(doc.title || "")}</div>`; return w; }
    function renderReview(doc) { const w = document.createElement("div"); w.className = "list-review-block"; w.innerHTML = `<div>${escapeHtml(doc.title || "")}</div>`; return w; }

    function executeSearch() {
  if (!DOCS || !DOCS.length) return;

  const q = fuzzyInput.value.trim();
  const tagFilters = activeTags.map(t => ({ tag: t.tag, negative: !!t.negative }));

  // --- special case: both bars empty -> show nothing ---
  if (!q && !tagFilters.length) {
    [listArticles, listPhotos, listVideos, listReviews].forEach(c => c.innerHTML = "");
    activateTab("results-tabs", "tab-articles");
    return;
  }

  let results = search(q, tagFilters, 2000);

  // --- TAG ONLY SORTING BY startDate ASC ---
  if (!q && tagFilters.length) {
    results.sort((a, b) => {
      const da = a.doc.frontmatter?.startDate || "0000-00-00";
      const db = b.doc.frontmatter?.startDate || "0000-00-00";

      // Push unknown/0000 dates to the bottom
      if (da.startsWith("0000") && db.startsWith("0000")) return 0;
      if (da.startsWith("0000")) return 1;
      if (db.startsWith("0000")) return -1;

      // Compare as strings "YYYY-MM-DD" works naturally
      return da.localeCompare(db);
    });
  }

  // --- split into tabs ---
  const articles = [], photos = [], videos = [], reviews = [];
  for (const r of results) {
    const doc = r.doc;
    const tags = (TAGS_BY_PAGE[doc.path] || []).map(t => t.toLowerCase());

    if (tags.includes("photos")) photos.push({ score: r.score, doc });
    else if (tags.includes("videos")) videos.push({ score: r.score, doc });
    else if (tags.includes("reviews")) reviews.push({ score: r.score, doc });
    else articles.push({ score: r.score, doc });
  }

  // --- render tabs ---
  function clearAndRender(container, arr, renderer) {
    container.innerHTML = "";
    if (!arr.length) {
      container.innerHTML = `<div class="no-results">No results</div>`;
      return;
    }
    for (const item of arr.slice(0, 200)) {
      container.appendChild(renderer(item.doc));
    }
  }

  clearAndRender(listArticles, articles, renderArticle);
  clearAndRender(listPhotos, photos, renderPhoto);
  clearAndRender(listVideos, videos, renderVideo);
  clearAndRender(listReviews, reviews, renderReview);

  // --- update tab counts ---
  const tabCounts = {
    "tab-articles": articles.length,
    "tab-photos": photos.length,
    "tab-videos": videos.length,
    "tab-reviews": reviews.length
  };
  SEARCH_TABS.forEach(key => {
    const btn = tabButtons.find(b => b.dataset.tab === key);
    if (!btn) return;
    const labelMap = {
      "tab-articles": "Articles",
      "tab-photos": "Photos",
      "tab-videos": "Videos",
      "tab-reviews": "Reviews"
    };
    btn.textContent = `${labelMap[key]} (${tabCounts[key] || 0})`;
  });
}


    // --- INIT ---
    (async function init() {
      await loadSearchData();
      executeSearch();
    })();

  });
</script>