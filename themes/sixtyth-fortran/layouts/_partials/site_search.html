{{- /*
Partial: site_search.html
Usage:
{{ partial "site_search.html" . }}

Notes:
- Loads search JSON data from /data/*.json via fetch.
*/ -}}

{{- $tagStyles := site.Data.tag_styles -}}
{{- $tagCounts := site.Data.tags.tag_counts -}}

<div class="search-ui-container">
  <div class="search-controls">
    <div class="search-tags-wrapper">
      <div id="tag-chip-container" class="tag-chip-container" tabindex="0">
        <input id="tag-input" class="tag-input" placeholder="Search by Title or Tag" autocomplete="off" />
      </div>
      <div id="tag-suggestions" class="tag-suggestions" aria-hidden="true"></div>
    </div>

    <div class="search-collapsible" id="search-collapsible">
      <div class="search-fuzzy-wrapper">
        <input id="fuzzy-q" class="search-fuzzy" placeholder="Search by Specific Text" autocomplete="off" />
      </div>

      <div class="search-layout">
        <aside class="search-left-col">
          <div class="predef-list">
            {{- $predef := slice
            "Pizza Time Theatre"
            "ShowBiz Pizza Place"
            "Chuck E. Cheese's"
            "2026"
            "1977"
            "Locations"
            "Showtapes"
            "Animatronic Shows"
            "Stage Variations"
            "Animatronics"
            "Animatronic Parts"
            "Animatronic Preservation"
            "Costumed Characters"
            "Retrofits"
            "History"
            "Cancelled Locations"
            "Remodels and Initiatives"
            "Arcades and Attractions"
            "Store Fixtures"
            "Companies/Brands"
            "Characters"
            "Events"
            "Animatronic Control Systems"
            "Other Systems"
            "Simulators"
            "Programming Systems"
            "Commercials"
            "News Footage"
            "Company Media"
            "Movies"
            "Puppets"
            "Live Shows"
            "ShowBiz Pizza Programs"
            "Showtape Formats"
            "Family Vision"
            "Corporate Documents"
            "Documents"
            "Promotional Material"
            "Social Media and Websites"
            "Ad Vehicles"
            "In-Store Merchandise"
            "Products"
            "Menu Items"
            "Tickets"
            "Tokens"
            "Employee Wear"
            "Video Games"
            "Sally Corporation"
            "Jim Henson's Creature Shop"
            "Walt Disney Imagineering"
            "Five Nights at Freddy's"
            "Transcriptions"
            "Unknown Year"
            "User"
            "Meta"
            -}}
            <div class="predef-tags">
              <h4>Quick Tags</h4>
              <div class="predef-scroll">
                <div class="predef-list">
                  {{- range $i, $t := $predef -}}
                    {{- $entry := index $tagStyles $t -}}
                    {{- $emoji := "" -}}
                    {{- $color := "" -}}
                    {{- if $entry -}}
                      {{- with $entry }}
                        {{- $emoji = .emoji -}}
                        {{- $color = .color -}}
                      {{- end -}}
                    {{- end -}}
                    {{- $count := index $tagCounts $t -}}
                    <button
                      class="predef-tag-btn"
                      type="button"
                      data-tag="{{ $t | html }}"
                      title="Add tag"
                      {{- if $color }}style="--tag-bg: {{ $color }};"{{- end -}}
                    >
                      {{- if $emoji }}{{ $emoji | safeHTML }} {{- end -}}
                      {{- $t -}}
                      {{- with $count -}} <span class="tag-count">({{ . }})</span>{{- end -}}
                    </button>
                  {{- end -}}
                </div>
              </div>
            </div>
          </div>
        </aside>

        <div class="tabs" id="results-tabs" hidden>

          <!-- Controls inserted above the tabs -->
          <div class="result-controls" style="margin-bottom:8px;">
            <label>
              Show:
              <select id="results-per-section" title="Results per section">
                <option value="10" selected>10</option>
                <option value="50">50</option>
                <option value="100">100</option>
                <option value="all">All</option>
              </select>
            </label>

            <label style="margin-left:10px;">
              Sort Articles:
              <select id="articles-sort" title="Sort articles">
                <option value="relevancy" selected>Relevancy</option>
                <option value="oldest">Oldest â†’ Newest</option>
                <option value="newest">Newest â†’ Oldest</option>
              </select>
            </label>
          </div>

          <div class="tab-buttons">
            <button class="tab-button active" data-tab="tab-articles">Articles</button>
            <button class="tab-button" data-tab="tab-photos">Photos</button>
            <button class="tab-button" data-tab="tab-videos">Videos</button>
            <button class="tab-button" data-tab="tab-reviews">Reviews</button>
          </div>

          <div class="tab-content">
            <div class="tab-panel active" id="tab-articles">
              <div class="results-summary" aria-live="polite"></div>
              <div class="results-list" id="list-articles"></div>
            </div>

            <div class="tab-panel" id="tab-photos">
              <div class="results-list" id="list-photos"></div>
            </div>

            <div class="tab-panel" id="tab-videos">
              <div class="results-list" id="list-videos"></div>
            </div>

            <div class="tab-panel" id="tab-reviews">
              <div class="results-list" id="list-reviews"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
  // --- DATA STORAGE ---
  let DOCS = [], TAGS_BY_PAGE = {}, PAGES_BY_TAG = {}, TAG_COUNTS = {}, ALL_TAGS = [];
  const DOC_TAGS = {}; // map normalized page path -> [tags]
  const SEARCH_TABS = ["tab-articles", "tab-photos", "tab-videos", "tab-reviews"];
  let activeTags = [];
  let searchTimer = null;

  // --- DOM ELEMENTS ---
  const tabButtons = Array.from(document.querySelectorAll(".tab-button"));
  const fuzzyInput = document.getElementById("fuzzy-q");
  const tagInput = document.getElementById("tag-input");
  const tagChipContainer = document.getElementById("tag-chip-container");
  const tagSuggestions = document.getElementById("tag-suggestions");
  const listArticles = document.getElementById("list-articles");
  const listPhotos = document.getElementById("list-photos");
  const listVideos = document.getElementById("list-videos");
  const listReviews = document.getElementById("list-reviews");
  const predefButtons = document.querySelectorAll(".predef-tag-btn");
  const resultsPerSelect = document.getElementById("results-per-section");
  const articlesSortSelect = document.getElementById("articles-sort");

  // collapsible support
  const trigger = document.getElementById("tag-input");
  const collapsible = document.getElementById("search-collapsible");

  // --- Helpers for path normalization & permalinks ---
  function normalizePageKey(raw) {
    if (!raw) return "";
    let p = (typeof raw === "object") ? (raw.path || "") : String(raw);
    p = p.trim();
    if (/^https?:\/\//i.test(p)) return p;
    if (p.startsWith("/")) p = p.slice(1);
    if (p.startsWith("content/")) p = p.slice("content/".length);
    if (p.endsWith("/")) p = p.slice(0, -1);
    p = p.replace(/\.(md|markdown|mdown)$/i, "");
    return p;
  }

  function makePermalink(rawPath) {
    if (!rawPath) return "#";
    if (/^https?:\/\//i.test(rawPath)) return rawPath;
    const key = normalizePageKey(rawPath);
    if (!key) return "/";
    if (key === "_index" || key === "") return "/";
    return "/" + key + (key.endsWith("/") ? "" : "/");
  }

  // --- collapsible open-once ---
  let opened = false;
  function openOnce() {
    if (!collapsible) return;
    if (opened) return;
    opened = true;
    collapsible.style.maxHeight = collapsible.scrollHeight + "px";
    collapsible.addEventListener("transitionend", () => {
      collapsible.style.maxHeight = "none";
    }, { once: true });
  }
  if (trigger) {
    trigger.addEventListener("click", openOnce);
    trigger.addEventListener("focus", openOnce);
  }

  // --- Basic text utilities ---
  const reNonWord = /[^\w\s]/g, reSpace = /\s+/g;
  function normalizeText(s) { if (!s) return ""; return String(s).toLowerCase().replace(reNonWord, " ").replace(reSpace, " ").trim(); }
  function tokenize(s) { if (!s) return []; return normalizeText(s).split(/\s+/).filter(Boolean); }
  function charTrigrams(s) { s = "  " + normalizeText(s) + "  "; const out = new Set(); for (let i = 0; i + 3 <= s.length; i++) out.add(s.slice(i, i + 3)); return out; }
  function jaccard(a, b) { if (!a.size || !b.size) return 0; let inter = 0; for (const x of a) if (b.has(x)) inter++; return inter / (a.size + b.size - inter); }
  function escapeHtml(s) { if (!s) return ""; return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;"); }

  // --- Tab activation helper ---
  function activateTab(containerId, panelId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    const btns = Array.from(container.querySelectorAll(".tab-button"));
    const panels = Array.from(container.querySelectorAll(".tab-panel"));
    btns.forEach(b => b.classList.toggle("active", b.dataset.tab === panelId));
    panels.forEach(p => p.classList.toggle("active", p.id === panelId));
  }
  tabButtons.forEach(b => b.addEventListener("click", () => activateTab("results-tabs", b.dataset.tab)));

  // --- Load JSON data and normalize keys ---
  async function loadSearchData() {
    const [docsRes, tagsRes, pagsRes, countsRes] = await Promise.all([
      fetch("/data/search/docs.json"),
      fetch("/data/tags/tags_by_page.json"),
      fetch("/data/tags/pages_by_tag.json"),
      fetch("/data/tags/tag_counts.json")
    ]);
    DOCS = await docsRes.json();
    TAGS_BY_PAGE = await tagsRes.json();
    PAGES_BY_TAG = await pagsRes.json();
    TAG_COUNTS = await countsRes.json();

    // build ALL_TAGS
    ALL_TAGS = Object.keys(TAG_COUNTS || {}).sort((a,b)=>a.localeCompare(b, undefined, {sensitivity:'base'}));

    // preprocess docs (tokens/trigrams) and ensure doc.path is normalized key form
    DOCS.forEach(doc => {
      const text = [doc.title || "", doc.excerpt || "", doc.content || "", doc.summary || ""].join(" ");
      doc.tokens = doc.tokens || Array.from(new Set(tokenize(text)));
      doc.trigrams = doc.trigrams || Array.from(charTrigrams(text));
      if (doc.path) doc.path = normalizePageKey(doc.path);
    });

    // Build DOC_TAGS by normalizing keys from TAGS_BY_PAGE
    for (const rawKey in TAGS_BY_PAGE) {
      const normKey = normalizePageKey(rawKey);
      DOC_TAGS[normKey] = TAGS_BY_PAGE[rawKey] || [];
    }

    // wire predef buttons (they were rendered server-side with counts/colors)
    const predefBtnsNow = document.querySelectorAll(".predef-tag-btn");
    predefBtnsNow.forEach(b => b.addEventListener("click", function(){ addTag(this.dataset.tag, false); }));

    console.log("Search data loaded", { DOCS, TAGS_BY_PAGE, PAGES_BY_TAG, TAG_COUNTS, ALL_TAGS });
  }

  // --- Tag UI: chips, suggestions, add/remove ---
  function addTag(tagStr, negative=false) {
    if (!tagStr) return;
    const found = ALL_TAGS.find(t => t.toLowerCase() === tagStr.toLowerCase());
    const canon = found || tagStr;
    const idx = activeTags.findIndex(t => t.tag.toLowerCase() === canon.toLowerCase() && t.negative === negative);
    if (idx !== -1) return;
    const opp = activeTags.findIndex(t => t.tag.toLowerCase() === canon.toLowerCase() && t.negative !== negative);
    if (opp !== -1) activeTags.splice(opp, 1);
    activeTags.push({ tag: canon, negative });
    renderTagChips();
  }

  function renderTagChips() {
    if (!tagChipContainer) return;
    Array.from(tagChipContainer.querySelectorAll(".tag-chip")).forEach(n => n.remove());
    activeTags.forEach((t, i) => {
      const chip = document.createElement("span");
      chip.className = "tag-chip " + (t.negative ? "tag-chip-neg" : "tag-chip-pos");
      chip.setAttribute("data-tag", t.tag);
      chip.innerHTML = `<button class="tag-chip-close" aria-label="Remove tag" data-idx="${i}">âœ•</button><span class="tag-chip-label">${t.negative?'-':''}${escapeHtml(t.tag)}</span>`;
      tagChipContainer.insertBefore(chip, tagInput);
    });
    if (tagInput) { tagInput.value = ""; tagInput.focus(); }
    scheduleSearch();
    updateSearchLayout();
  }

  if (tagChipContainer) {
    tagChipContainer.addEventListener("click", (e) => {
      const btn = e.target.closest(".tag-chip-close");
      if (!btn) return;
      const idx = Number(btn.getAttribute("data-idx"));
      if (!Number.isNaN(idx)) {
        activeTags.splice(idx, 1);
        renderTagChips();
      }
    });
  }

  // --- Tag suggestion logic (only from TAG_COUNTS / ALL_TAGS) ---
  let suggestionIndex = -1;
  function suggestTags(prefix, limit=10) {
    if (!prefix) return [];
    let isNeg = false;
    if (prefix.startsWith("-")) { isNeg = true; prefix = prefix.slice(1).trim(); }
    const q = normalizeText(prefix);
    if (!q) return [];
    const matches = ALL_TAGS
      .map(tag => ({ tag, count: TAG_COUNTS[tag] || 0, negative: isNeg }))
      .filter(t => normalizeText(t.tag).includes(q))
      .sort((a,b) => {
        if (b.count !== a.count) return b.count - a.count;
        return a.tag.localeCompare(b.tag);
      })
      .slice(0, limit);
    return matches;
  }

  function showSuggestions(list) {
    if (!tagSuggestions) return;
    tagSuggestions.innerHTML = "";
    if (!list || !list.length) {
      tagSuggestions.style.display = "none";
      tagSuggestions.setAttribute("aria-hidden","true");
      suggestionIndex = -1;
      return;
    }
    tagSuggestions.style.display = "block";
    tagSuggestions.setAttribute("aria-hidden","false");
    list.forEach((s,i) => {
      const el = document.createElement("div");
      el.className = "tag-suggestion";
      el.dataset.i = i;
      el.innerHTML = `<span class="suggest-tag">${s.negative?'-':''}${escapeHtml(s.tag)}</span> <span class="suggest-count">(${s.count||0})</span>`;

      // click: mousedown to avoid losing focus
      el.addEventListener("mousedown", ev => { ev.preventDefault(); addTag(s.tag, s.negative); hideSuggestions(); });

      // mouseover: set active suggestion for Tab behavior & arrow navigation
      el.addEventListener("mouseover", () => {
        const items = Array.from(tagSuggestions.querySelectorAll(".tag-suggestion"));
        items.forEach((it,i2) => it.classList.toggle("active", i2 === i));
        suggestionIndex = i;
      });

      tagSuggestions.appendChild(el);
    });
    suggestionIndex = -1;
    tagSuggestions.scrollTop = 0;
  }

  function hideSuggestions() { if (!tagSuggestions) return; tagSuggestions.innerHTML=""; tagSuggestions.style.display="none"; tagSuggestions.setAttribute("aria-hidden","true"); suggestionIndex = -1; }

  if (tagInput) {
    tagInput.addEventListener("input", () => {
      const v = tagInput.value || "";
      if (!v.trim()) { hideSuggestions(); return; }
      showSuggestions(suggestTags(v, 12));
    });

    tagInput.addEventListener("keydown", (e) => {
      const v = tagInput.value || "";
      const items = tagSuggestions ? Array.from(tagSuggestions.querySelectorAll(".tag-suggestion")) : [];

      if (e.key === "Enter") {
        e.preventDefault();
        addTag(v.trim().startsWith("-") ? v.trim().slice(1) : v.trim(), v.trim().startsWith("-"));
        hideSuggestions();
      } else if (e.key === "Tab") {
        if (items.length) {
          e.preventDefault();
          // If an item is highlighted (via arrow keys or mouseover), pick that.
          // Otherwise pick the first item.
          const activeItem = items.find(it => it.classList.contains("active")) || items[0];
          if (activeItem) {
            const txt = activeItem.querySelector(".suggest-tag").textContent || "";
            addTag(txt.startsWith("-") ? txt.slice(1) : txt, txt.startsWith("-"));
            hideSuggestions();
          }
        }
      } else if (e.key === "ArrowDown") {
        if (items.length) {
          e.preventDefault();
          suggestionIndex = Math.min(suggestionIndex + 1, items.length - 1);
          items.forEach((it,i)=> it.classList.toggle("active", i===suggestionIndex));
          items[suggestionIndex].scrollIntoView({block:"nearest"});
        }
      } else if (e.key === "ArrowUp") {
        if (items.length) {
          e.preventDefault();
          suggestionIndex = Math.max(suggestionIndex - 1, 0);
          items.forEach((it,i)=> it.classList.toggle("active", i===suggestionIndex));
          items[suggestionIndex].scrollIntoView({block:"nearest"});
        }
      } else if (e.key === "Escape") {
        hideSuggestions();
      }
    });

    document.addEventListener("click", (e) => {
      if (!tagSuggestions || !tagInput) return;
      if (!tagSuggestions.contains(e.target) && e.target !== tagInput) hideSuggestions();
    });
  }


  function scheduleSearch() { if (searchTimer) clearTimeout(searchTimer); searchTimer = setTimeout(executeSearch, 150); }
  if (fuzzyInput) {
    fuzzyInput.addEventListener("input", () => { scheduleSearch(); updateSearchLayout(); });
    fuzzyInput.addEventListener("keydown", e => { if (e.key === "Enter") { e.preventDefault(); executeSearch(); } });
  }

  // --- Init load ---
  (async function init() {
    await loadSearchData();
    executeSearch();
    updateSearchLayout();
  })();


  // --- Layout control: show tags vs show results ---
  function updateSearchLayout() {
    const textInput = fuzzyInput;
    const tagPanel = document.querySelector(".search-left-col");
    const resultsPanel = document.getElementById("results-tabs");
    if (!tagPanel || !resultsPanel) return;
    const hasText = textInput && textInput.value.trim().length > 0;
    const hasTags = activeTags.length > 0;
    const showResults = hasText || hasTags;
    if (showResults) { tagPanel.hidden = true; resultsPanel.hidden = false; }
    else { tagPanel.hidden = false; resultsPanel.hidden = true; }
  }

  // --- Scoring & search helpers ---
  function docHasTag(doc, tag) {
    if (!doc || !doc.path) return false;
    const tags = DOC_TAGS[doc.path] || [];
    const lk = tag.toLowerCase();
    for (const t of tags) if (String(t).toLowerCase() === lk) return true;
    return false;
  }

  function scoreDocForQuery(doc, qTokens, qTris) {
    const docTris = new Set(doc.trigrams || []), docTokens = new Set(doc.tokens || []);
    let tJ = jaccard(qTris, docTris);
    let tokOverlap = 0;
    if (qTokens.length) tokOverlap = qTokens.filter(t => docTokens.has(t)).length / qTokens.length;
    let titleBoost = 0;
    const titleLower = (doc.title || "").toLowerCase();
    for (const t of qTokens) if (titleLower.includes(t)) { titleBoost = 0.12; break; }
    return 0.72 * tJ + 0.26 * tokOverlap + titleBoost;
  }

  // compute trigram similarity between a title string and a query string
  function titleSimilarityToQuery(doc, queryStr) {
    const titleStr = (doc.title || doc.path || "");
    if (!titleStr || !queryStr) return 0;
    const tTris = charTrigrams(titleStr);
    const qTris = charTrigrams(queryStr);
    return jaccard(tTris, qTris);
  }

  // --- SEARCH (handles tag-only and fuzzy+tags) ---
  function search(fuzzyQuery, tagFilters, maxResults=500) {
    let results = [];
    const isFuzzyEmpty = !fuzzyQuery || !fuzzyQuery.trim();
    const isTagOnly = isFuzzyEmpty && tagFilters.length > 0;

    if (isTagOnly) {
      // TAG-ONLY: produce candidatePaths then score by title similarity to tag(s)
      let candidatePaths = null;
      tagFilters.forEach(tf => {
        const tagKey = tf.tag;
        const pagesForTagObjs = PAGES_BY_TAG[tagKey] || [];
        // normalize page paths from pagesByTag entries
        const pagesForTag = pagesForTagObjs.map(p => normalizePageKey(p.path || p));
        if (tf.negative) {
          if (!candidatePaths) candidatePaths = Object.values(PAGES_BY_TAG).flat().map(p => normalizePageKey(p.path || p));
          candidatePaths = candidatePaths.filter(p => !pagesForTag.includes(p));
        } else {
          if (!candidatePaths) candidatePaths = [...pagesForTag];
          else candidatePaths = candidatePaths.filter(p => pagesForTag.includes(p));
        }
      });

      if (!candidatePaths) candidatePaths = [];

      // Determine positive tags to compute similarity against
      const positiveTags = tagFilters.filter(t => !t.negative).map(t => t.tag);

      results = candidatePaths.map(p => {
        const doc = DOCS.find(d => d.path === p) || { path: p, title: p, frontmatter: {} };
        let score = 0;
        if (positiveTags.length > 0) {
          // average similarity across positive tags, computed against the title
          let acc = 0;
          positiveTags.forEach(pt => {
            acc += titleSimilarityToQuery(doc, pt);
          });
          score = acc / positiveTags.length;
          // give a noticeable boost to exact title matches (force them to top)
          for (const pt of positiveTags) {
            if ((doc.title || "").toLowerCase() === pt.toLowerCase()) {
              score += 1.0; // big boost ensures exact title match ranks highest
              break;
            }
          }
        } else {
          // no positive tags (e.g., only negatives) -> leave score as 0
          score = 0;
        }
        return { score, doc };
      });

      // Sort by score descending; exact title matches have higher score due to boost above.
      results.sort((a,b) => {
        const diff = (b.score || 0) - (a.score || 0);
        if (Math.abs(diff) > 1e-9) return diff;
        // tie-breaker: keep date ordering similar to previous behavior (oldest first)
        const aStart = (a.doc.frontmatter?.startDate || "0000-00-00").split(" ")[0];
        const bStart = (b.doc.frontmatter?.startDate || "0000-00-00").split(" ")[0];
        if ((aStart && aStart.startsWith("0000")) && !(bStart && bStart.startsWith("0000"))) return 1;
        if ((bStart && bStart.startsWith("0000")) && !(aStart && aStart.startsWith("0000"))) return -1;
        return aStart.localeCompare(bStart);
      });

    } else {
      // FUZZY + optional tag filters
      const qTokens = tokenize(fuzzyQuery);
      const qTris = charTrigrams(fuzzyQuery);
      for (const doc of DOCS) {
        let ok = true;
        for (const tf of tagFilters) {
          const want = tf.tag;
          if (tf.negative) {
            if (docHasTag(doc, want)) { ok = false; break; }
          } else {
            if (!docHasTag(doc, want)) { ok = false; break; }
          }
        }
        if (!ok) continue;
        const score = scoreDocForQuery(doc, qTokens, qTris);
        if (score > 0) results.push({ score, doc });
      }
      results.sort((a,b) => b.score - a.score);
    }

    return results.slice(0, maxResults);
  }

  // --- Renderers (use makePermalink for internal links) ---
  function renderArticle(doc) {
    const fm = doc.frontmatter || {};
    const hasContent = !!(doc.content || doc.excerpt || doc.title);
    const wrapper = document.createElement("div");
    wrapper.className = hasContent ? "list-page-block" : "list-page-empty-block";

    const formatDateShort = dateStr => {
      if (!dateStr || dateStr === "0000-00-00") return "?";
      const parts = (dateStr.split(" ")[0]||"").split("-");
      const year = parts[0] || "0000";
      const month = parts[1] || "00";
      const day = parts[2] || "00";
      const months = { "00": "", "01":"Jan. ", "02":"Feb. ", "03":"Mar. ", "04":"Apr. ", "05":"May ", "06":"Jun. ", "07":"Jul. ", "08":"Aug. ", "09":"Sep. ", "10":"Oct. ", "11":"Nov. ", "12":"Dec." };
      const days = { "00":"", "01":"1, ", "02":"2, ", "03":"3, ", "04":"4, ", "05":"5, ", "06":"6, ", "07":"7, ", "08":"8, ", "09":"9, " };
      return `${months[month] || ""}${(days[day]||"")}${year !== "0000" ? year : ""}`;
    };

    const startDate = formatDateShort(fm.startDate);
    const endDate = formatDateShort(fm.endDate);
    const imgSrc = fm.pageThumbnailFile ? `/photos/${fm.pageThumbnailFile}` : "/UI/File%20Not%20Found.jpg";
    const href = makePermalink(doc.path);

    wrapper.innerHTML = `
      <div class="list-page-container">
        <div class="list-image">
          <a href="${href}">
            <img src="${imgSrc}" class="thumbnail" />
          </a>
        </div>
        <div class="list-page-content">
          <a href="${href}">
            ${escapeHtml(fm.title || doc.title || doc.path)}
            ${fm.downloadLinks && fm.downloadLinks.length ? '<img src="/UI/Emojis/inbox.svg" class="emoji">' : ""}
          </a>
          <div class="list-page-date">
            ${startDate} - ${endDate}
          </div>
        </div>
      </div>
    `;
    return wrapper;
  }

  function formatDate(date) {
    if (!date || date === "0000-00-00") return "?";
    const parts = (date || "").split("-");
    if (parts.length !== 3) return date;
    const year = parts[0] === "0000" ? "?" : parts[0];
    const monthNum = Number(parts[1]);
    const dayNum = Number(parts[2]);
    const months = ["","Jan.","Feb.","Mar.","Apr.","May","Jun.","Jul.","Aug.","Sep.","Oct.","Nov.","Dec."];
    let monthStr = months[monthNum] || "";
    let dayStr = dayNum ? `${dayNum}` : "";
    if (!monthStr && !dayStr) return year;
    if (monthStr && !dayStr) return `${monthStr} ${year}`;
    if (!monthStr && dayStr) return `${dayStr} ${year}`;
    return `${monthStr} ${dayStr}, ${year}`;
  }

  function renderPhoto(doc) {
    const wrapper = document.createElement("div");
    wrapper.className = "gallery-image-box";
    let fileName = (doc.title || "").trim(); // expects the filename/title to be the photo filename
    let imgURL = "/UI/File Not Found.jpg";
    let lowResURL = "/UI/File Not Found.jpg";

    if (fileName) {
      // If the doc.title contains directories or leading slash, strip leading slash
      if (fileName.startsWith("/")) fileName = fileName.slice(1);
      // Build low-res and high-res urls
      lowResURL = `/lowphotos/${fileName}`;
      imgURL = `/photos/${fileName}`;
    }

    const formattedStart = formatDate(doc.frontmatter?.startDate || "");
    const formattedEnd = formatDate(doc.frontmatter?.endDate || "");
    const dateStr = formattedStart || formattedEnd ? `${formattedStart}${formattedEnd ? ` - ${formattedEnd}` : ""}` : "";
    const photoDesc = doc.frontmatter?.photoDescription?.trim();
    const displayText = photoDesc || doc.title + (dateStr ? ` (${dateStr})` : "");
    const href = makePermalink(doc.path);

    // low res in src, HD in data-src, class lazy-photo - your CSS/JS can swap data-src into src
    wrapper.innerHTML = `
      <div class="article-photo-image">
        <a href="${href}">
          <img src="${lowResURL}" data-src="${imgURL}" alt="${escapeHtml(doc.title || "File Not Found")}" class="lazy-photo" loading="lazy" />
        </a>
      </div>
      <div class="article-photo-description">${escapeHtml(displayText)}</div>
    `;
    return wrapper;
  }

  function renderVideo(doc) {
    const wrapper = document.createElement("div");
    wrapper.className = "list-page-block-video";
    const container = document.createElement("div"); container.className = "list-page-container";

    const videoDiv = document.createElement("div"); videoDiv.className = "list-video";
    const videoURL = doc.title || "";
    let thumbURL = "/UI/File Not Found.jpg";
    if (videoURL.includes("youtube.com")) {
      const videoID = videoURL.replace("https://www.youtube.com/watch?v=","").split("&")[0];
      thumbURL = `https://img.youtube.com/vi/${videoID}/mqdefault.jpg`;
    } else if (videoURL.includes("youtu.be")) {
      const parts = videoURL.split("/"); const videoID = parts[parts.length-1]; thumbURL = `https://img.youtube.com/vi/${videoID}/mqdefault.jpg`;
    } else if (videoURL.includes("archive.org")) {
      const parts = videoURL.split("/"); const videoID = parts[4] || ""; if (videoID) thumbURL = `https://archive.org/services/img/${videoID}`;
    }
    const thumbLink = document.createElement("a"); thumbLink.href = videoURL; thumbLink.target = "_blank";
    const thumbImg = document.createElement("img"); thumbImg.src = thumbURL; thumbImg.alt = "Video Thumbnail";
    thumbLink.appendChild(thumbImg); videoDiv.appendChild(thumbLink);

    const contentDiv = document.createElement("div"); contentDiv.className = "list-page-video-content";
    const aLink = document.createElement("a"); aLink.href = makePermalink(doc.path || "#");
    const excerpt = (doc.excerpt || "").substring(0,150);
    aLink.textContent = excerpt.length < (doc.excerpt || "").length ? excerpt + "..." : excerpt;
    contentDiv.appendChild(aLink);
    const dateDiv = document.createElement("div"); dateDiv.className = "list-page-date";
    dateDiv.textContent = formatDate(doc.frontmatter?.startDate || "");
    contentDiv.appendChild(dateDiv);

    container.appendChild(videoDiv); container.appendChild(contentDiv); wrapper.appendChild(container);
    return wrapper;
  }

  function renderReview(doc) {
    const wrapper = document.createElement("div");
    wrapper.className = "list-review-block";
    const container = document.createElement("div"); container.className = "list-review-container";
    const contentDiv = document.createElement("div"); contentDiv.className = "list-review-content";

    const aLink = document.createElement("a"); aLink.href = makePermalink(doc.path || "#");
    const recommend = doc.frontmatter?.recommend;
    const baseTitle = doc.frontmatter?.LinkTitle || doc.title || "";

    // append reviewed page (Page param) if present
    let reviewedPageStr = "";
    const pageTitle = doc.frontmatter?.Page;
    if (pageTitle) {
      const match = DOCS.find(d => d.title === pageTitle);
      if (match) reviewedPageStr = ` - <a href="${makePermalink(match.path)}">${escapeHtml(match.title)}</a>`;
      else reviewedPageStr = ` - ${escapeHtml(pageTitle)}`;
    }
    aLink.innerHTML = (recommend === true ? "ðŸ‘ " : "ðŸ‘Ž ") + escapeHtml(baseTitle) + reviewedPageStr;
    contentDiv.appendChild(aLink);

    const dateDiv = document.createElement("div"); dateDiv.className = "list-review-date";
    const startDate = doc.frontmatter?.startDate || "";
    let dateText = formatDate(startDate);
    const contributors = doc.frontmatter?.contributors || [];
    if (contributors.length > 0) {
      const contribLinks = contributors.map(c => {
        const match = DOCS.find(d => d.title === c);
        if (match) return `<a href="${makePermalink(match.path)}">${escapeHtml(match.title)}</a>`;
        return escapeHtml(c);
      }).join(", ");
      dateText += ` - ${contribLinks}`;
    } else {
      dateText += " - Anonymous";
    }
    dateDiv.innerHTML = dateText;
    contentDiv.appendChild(dateDiv);

    const bodyDiv = document.createElement("div"); bodyDiv.className = "list-review-body";
    bodyDiv.innerHTML = escapeHtml(doc.excerpt || doc.content || "");
    contentDiv.appendChild(bodyDiv);

    container.appendChild(contentDiv); wrapper.appendChild(container);
    return wrapper;
  }

  // --- Utility to parse and compare dates for sorting, push 0000/blank to bottom ---
  function dateSortableRaw(raw) {
    if (!raw) return null;
    const s = String(raw).split(" ")[0];
    if (!s) return null;
    if (s.startsWith("0000")) return null;
    return s; // YYYY-MM-DD expected
  }
  function compareDatesForSort(aRaw, bRaw, order='oldest') {
    const a = dateSortableRaw(aRaw), b = dateSortableRaw(bRaw);
    if (!a && !b) return 0;
    if (!a) return 1; // push a to bottom
    if (!b) return -1; // push b to bottom
    if (order === 'oldest') return a.localeCompare(b);
    return b.localeCompare(a);
  }

  // --- executeSearch & rendering control ---
  function executeSearch() {
    if (!DOCS || !DOCS.length) {
      console.warn("Search data not yet loaded or empty");
      return;
    }

    const q = fuzzyInput ? fuzzyInput.value.trim() : "";
    const tagFilters = activeTags.map(t => ({ tag: t.tag, negative: !!t.negative }));

    // both empty -> clear results and show tag panel
    if (!q && !tagFilters.length) {
      [listArticles, listPhotos, listVideos, listReviews].forEach(c => { if (c) c.innerHTML = ""; });
      activateTab("results-tabs", "tab-articles");
      updateSearchLayout();
      return;
    }

    const results = search(q, tagFilters, 2000);

    const articles=[], photos=[], videos=[], reviews=[];
    for (const r of results) {
      const doc = r.doc;
      const tags = (DOC_TAGS[doc.path] || []).map(t=>String(t).toLowerCase());
      if (tags.includes("photos")) photos.push({score:r.score, doc});
      else if (tags.includes("videos")) videos.push({score:r.score, doc});
      else if (tags.includes("reviews")) reviews.push({score:r.score, doc});
      else articles.push({score:r.score, doc});
    }

    // Apply articles sorting (per dropdown)
    const artSort = (articlesSortSelect && articlesSortSelect.value) ? articlesSortSelect.value : 'relevancy';

    if (artSort === 'relevancy') {
      // sort by score descending; tie-breaker: newest first
      articles.sort((A,B) => {
        const diff = (B.score || 0) - (A.score || 0);
        if (Math.abs(diff) > 1e-9) return diff;
        const aDate = A.doc.frontmatter?.startDate || A.doc.frontmatter?.date || "";
        const bDate = B.doc.frontmatter?.startDate || B.doc.frontmatter?.date || "";
        return compareDatesForSort(aDate, bDate, 'newest');
      });
    } else {
      // date-based sorts; always keep 0000/blank at bottom
      articles.sort((A,B) => {
        const aDate = A.doc.frontmatter?.startDate || A.doc.frontmatter?.date || "";
        const bDate = B.doc.frontmatter?.startDate || B.doc.frontmatter?.date || "";
        return compareDatesForSort(aDate, bDate, artSort);
      });
    }

    // Apply the "results per section" limit
    const perVal = resultsPerSelect && resultsPerSelect.value ? resultsPerSelect.value : "10";
    const perLimit = perVal === "all" ? Infinity : parseInt(perVal, 10) || 10;

    function clearAndRender(container, arr, renderer) {
      if (!container) return;
      container.innerHTML = "";
      if (!arr.length) { container.innerHTML = `<div class="no-results">No results</div>`; return; }
      const limited = (perLimit === Infinity) ? arr : arr.slice(0, perLimit);
      if (renderer === renderPhoto) {
        const gallery = document.createElement("div"); gallery.className = "gallery";
        limited.forEach(item => gallery.appendChild(renderer(item.doc)));
        container.appendChild(gallery);
      } else {
        limited.forEach(item => container.appendChild(renderer(item.doc)));
      }
    }

    clearAndRender(listArticles, articles, renderArticle);
    clearAndRender(listPhotos, photos, renderPhoto);
    clearAndRender(listVideos, videos, renderVideo);
    clearAndRender(listReviews, reviews, renderReview);

    // update tab counts
    const tabCounts = { "tab-articles": articles.length, "tab-photos": photos.length, "tab-videos": videos.length, "tab-reviews": reviews.length };
    SEARCH_TABS.forEach(key => {
      const btn = tabButtons.find(b=>b.dataset.tab===key);
      if (!btn) return;
      const labelMap = { "tab-articles":"Articles", "tab-photos":"Photos", "tab-videos":"Videos", "tab-reviews":"Reviews" };
      btn.textContent = `${labelMap[key]} (${tabCounts[key]||0})`;
    });

    updateSearchLayout();
  }

  // --- wire fuzzy input scheduling (tag changes call schedule via renderTagChips) ---
  function scheduleSearchAndLayout() { scheduleSearch(); updateSearchLayout(); }

  // wire result-controls to re-run search when changed
  if (resultsPerSelect) {
    resultsPerSelect.addEventListener("change", () => { executeSearch(); updateSearchLayout(); });
  }
  if (articlesSortSelect) {
    articlesSortSelect.addEventListener("change", () => { executeSearch(); updateSearchLayout(); });
  }

  // --- INIT already called above in IIFE ---

});
</script>
