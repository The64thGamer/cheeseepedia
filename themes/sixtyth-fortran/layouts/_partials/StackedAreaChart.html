{{- /* Partial: graph.html (stacked area + legend outside + scrollable, ignoring any series labeled "total") */ -}}

{{ $id := .id | default (printf "graph-%d" (now.UnixNano) ) }}
{{ $json := .data | jsonify }}
{{ $type := .type | default "auto" }}
{{ $height := .height | default 320 }}
{{ $width := .width | default 800 }}

<div id="{{ $id }}-container" style="display:flex; flex-direction:column; max-width:100%;">
  <div id="{{ $id }}" class="hugochart" role="img" aria-label="Stacked area chart"
       data-chart='{{ $json | safeJS }}' data-chart-type="{{ $type }}"
       style="max-width:100%;"></div>

  <div id="{{ $id }}-legend" class="hugochart-legend">
    <!-- legend items inserted via JS -->
  </div>
</div>

<script>
(function(){
  if (window.__hugochart_inited === undefined) {
    window.__hugochart_inited = true;

    function slug(s){ return String(s||"").toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,''); }

    function extent(arr){ var min=Infinity,max=-Infinity; arr.forEach(function(v){ if (v!=null && !isNaN(v)){ min=Math.min(min,v); max=Math.max(max,v);} }); return [min===Infinity?null:min, max===-Infinity?null:max]; }
    function linearScale(domainMin, domainMax, rangeMin, rangeMax){
      var d0 = domainMin, d1 = domainMax;
      if (d0 === d1) { d0 = d0 - 1; d1 = d1 + 1; }
      var m = (rangeMax - rangeMin) / (d1 - d0);
      return function(x){ return rangeMin + ( (x - d0) * m ); };
    }
    function fmtInt(v){ if (v == null || isNaN(v)) return ""; return Math.round(v).toLocaleString(); }

    function drawChart(container, opts){
      var data = opts.data;
      var w = opts.width || {{ $width }};
      var h = opts.height || {{ $height }};
      var padding = {left:60, right:20, top:28, bottom:44};

      var years = (data.years || []).map(y => +y);

      // Build series map (same heuristics as before)
      var seriesMap = {};
      if (data.openings && data.closings && data.openings.length === years.length){
        seriesMap["Openings"] = data.openings;
        seriesMap["Closings"] = data.closings;
      } else if (data.series){
        seriesMap = Object.assign({}, data.series);
      } else {
        for (var k in data) {
          if (!Array.isArray(data[k])) continue;
          if (k === "years") continue;
          if (k === "y") continue;
          if (data[k].length === years.length) seriesMap[k] = data[k];
        }
      }

      // === IGNORE any series labeled exactly "total" (case-insensitive, trimmed) ===
      Object.keys(seriesMap).forEach(function(k){
        if (String(k).trim().toLowerCase() === "total") {
          delete seriesMap[k];
        }
      });

      var seriesNames = Object.keys(seriesMap);

      // Convert values to numbers, treat null/"" as zero for stacking
      seriesNames.forEach(function(k){
        seriesMap[k] = seriesMap[k].map(function(v){ if (v==null || v==="") return 0; return +v; });
      });

      // Compute per-year stacked totals to determine y-domain
      var totals = [];
      for (var i=0;i<years.length;i++){
        var sum = 0;
        for (var s=0;s<seriesNames.length;s++){
          var v = seriesMap[seriesNames[s]][i];
          if (v == null || isNaN(v)) v = 0;
          sum += v;
        }
        totals.push(sum);
      }
      var yMax = extent(totals)[1];
      if (yMax === null || isNaN(yMax)) yMax = 1;
      var ydomain = [0, yMax];

      var xdomain = extent(years); if(xdomain[0]===null) xdomain=[0,(years.length?years.length-1:1)];

      var svgNS="http://www.w3.org/2000/svg";
      function el(name, attrs){ var e=document.createElementNS(svgNS,name); for(var k in (attrs||{})){ e.setAttribute(k,attrs[k]); } return e; }

      var svg=el("svg",{viewBox:"0 0 "+w+" "+h, preserveAspectRatio:"xMidYMid meet", class:"hugochart-svg"});
      svg.style.width="100%"; svg.style.height="auto";
      container.innerHTML=""; container.appendChild(svg);

      var innerW=w-padding.left-padding.right;
      var innerH=h-padding.top-padding.bottom;
      var xScale=linearScale(xdomain[0], xdomain[1], padding.left, padding.left+innerW);
      var yScale=linearScale(ydomain[0], ydomain[1], padding.top+innerH, padding.top);

      // Axes
      svg.appendChild(el("line",{x1:padding.left, y1:padding.top+innerH, x2:padding.left+innerW, y2:padding.top+innerH, class:"axis x-axis"}));
      svg.appendChild(el("line",{x1:padding.left, y1:padding.top, x2:padding.left, y2:padding.top+innerH, class:"axis y-axis"}));

      // X ticks
      var maxTicks=12; var step=Math.max(1,Math.ceil((xdomain[1]-xdomain[0])/maxTicks));
      var ticks=[]; for(var yy=xdomain[0]; yy<=xdomain[1]; yy+=step) ticks.push(Math.round(yy));
      if(ticks.length===0 && years.length) ticks=years;
      ticks.forEach(function(t){ var x=xScale(t); var y=padding.top+innerH;
        svg.appendChild(el("line",{x1:x,y1:y,x2:x,y2:y+6,class:"tick x-tick"}));
        var tx=el("text",{x:x,y:y+22,"text-anchor":"middle",class:"tick-label x-tick-label"}); tx.textContent=t; svg.appendChild(tx);
      });

      // Y ticks & grid
      var yTicksCount=4;
      for(var i=0;i<=yTicksCount;i++){ var v=ydomain[0]+((ydomain[1]-ydomain[0])*(i/yTicksCount)); var y=yScale(v);
        svg.appendChild(el("line",{x1:padding.left-6,y1:y,x2:padding.left,y2:y,class:"tick y-tick"}));
        svg.appendChild(el("line",{x1:padding.left,y1:y,x2:padding.left+innerW,y2:y,class:"grid y-grid"}));
        var ty=el("text",{x:padding.left-10,y:y+4,"text-anchor":"end",class:"tick-label y-tick-label"}); ty.textContent=fmtInt(v); svg.appendChild(ty);
      }

      // palette
      var palette = [
        "#6bffd3",  "#ff6b6b", "#ff9f43", "#ffe66d", "#8dff6b", "#6b9fff", "#8d6bff",
        "#ff0000", "#ff7f00", "#ffff00", "#7fff00", "#00ff00", "#00ff7f", "#00ffff",
        "#007fff", "#0000ff", "#7f00ff", "#ff00ff", "#ff007f", "#ff4500", "#ffd700",
        "#32cd32", "#00fa9a", "#1e90ff", "#8a2be2", "#ff1493", "#ff6347", "#7cfc00",
        "#40e0d0", "#6a5acd", "#ff69b4"
      ];

      // Build cumulative lower/upper bounds for each series (stack order = seriesNames order)
      var lower = []; var upper = [];
      var running = new Array(years.length).fill(0);
      for (var s=0;s<seriesNames.length;s++){
        var vals = seriesMap[seriesNames[s]];
        lower[s] = running.slice(); // copy current baseline
        upper[s] = new Array(years.length);
        for (var i=0;i<years.length;i++){
          var v = vals[i]; if (v==null || isNaN(v)) v = 0;
          upper[s][i] = running[i] + v;
        }
        for (var i=0;i<years.length;i++) running[i] = upper[s][i];
      }

      // Draw stacked areas (from bottom series to top)
      for (var s=0;s<seriesNames.length;s++){
        var name = seriesNames[s];
        var top = upper[s];
        var bot = lower[s];
        var pathD = "";
        var first = true;
        for (var i=0;i<years.length;i++){
          var xv = xScale(years[i]);
          var yv = yScale(top[i]);
          if (first){ pathD += "M " + xv + " " + yv + " "; first=false; }
          else { pathD += "L " + xv + " " + yv + " "; }
        }
        for (var i=years.length-1;i>=0;i--){
          var xv = xScale(years[i]);
          var yv = yScale(bot[i]);
          pathD += "L " + xv + " " + yv + " ";
        }
        pathD += "Z";

        var fillColor = palette[s % palette.length];
        var area = el("path",{d:pathD, fill: fillColor, "fill-opacity":"0.8", "data-series":name, class:"hugochart-area series-"+slug(name)});
        svg.appendChild(area);

        // draw thin top edge for visual separation
        var edgeD = "";
        var edgeFirst=true;
        for (var i=0;i<years.length;i++){
          var xv = xScale(years[i]);
          var yv = yScale(top[i]);
          if (edgeFirst){ edgeD += "M " + xv + " " + yv + " "; edgeFirst=false; }
          else { edgeD += "L " + xv + " " + yv + " "; }
        }
        var edge = el("path",{d:edgeD, fill:"none", stroke: shadeColor(fillColor, -20), "stroke-width":"1", class:"hugochart-edge series-"+slug(name)});
        svg.appendChild(edge);
      }

      if(opts.title){ var t=el("text",{x:padding.left+innerW/2,y:padding.top-6,"text-anchor":"middle",class:"chart-title"}); t.textContent=opts.title; svg.appendChild(t); }

      // OUTSIDE LEGEND (note: 'total' series has already been removed)
      var legendDiv = document.getElementById(opts.containerId + "-legend");
      if (legendDiv) {
        legendDiv.innerHTML = "";

        // sort series: 'Total' first (not present anymore) then keep order
        var sortedSeries = seriesNames.slice();

        sortedSeries.forEach(function(name, idx){
          var item = document.createElement("div");
          item.style.display = "flex";
          item.style.alignItems = "center";
          item.style.marginBottom = "4px";

          var swatch = document.createElement("div");
          swatch.style.width = "12px";
          swatch.style.height = "12px";
          swatch.style.backgroundColor = palette[seriesNames.indexOf(name) % palette.length];
          swatch.style.marginRight = "6px";
          swatch.style.borderRadius = "2px";

          var label = document.createElement("div");
          label.textContent = name;
          label.style.flex = "1";

          item.appendChild(swatch);
          item.appendChild(label);
          legendDiv.appendChild(item);
        });
      }

      // small helper to darken stroke color for edges (hex)
      function shadeColor(hexColor, percent) {
        try {
          var c = hexColor.replace('#','');
          if (c.length===3) c = c.split('').map(function(x){return x+x;}).join('');
          var r = parseInt(c.substr(0,2),16);
          var g = parseInt(c.substr(2,2),16);
          var b = parseInt(c.substr(4,2),16);
          r = Math.min(255, Math.max(0, r + Math.round(255 * (percent/100))));
          g = Math.min(255, Math.max(0, g + Math.round(255 * (percent/100))));
          b = Math.min(255, Math.max(0, b + Math.round(255 * (percent/100))));
          return "#" + [r,g,b].map(function(n){ return n.toString(16).padStart(2,'0'); }).join('');
        } catch(e){ return hexColor; }
      }

    } // drawChart

    function initAll(){
      var nodes=document.querySelectorAll(".hugochart");
      nodes.forEach(function(node){
        if(node.getAttribute("data-hugochart-rendered")) return;
        try{
          var raw=node.getAttribute("data-chart"); if(!raw) return;
          var data=JSON.parse(raw); var type=node.getAttribute("data-chart-type")||"auto";
          var width=node.getAttribute("data-width")||null; var height=node.getAttribute("data-height")||null;
          var title=node.getAttribute("data-title")||null;
          drawChart(node,{data:data,type:type,width:width?+width:undefined,height:height?+height:undefined,title:title,containerId:node.id});
          node.setAttribute("data-hugochart-rendered","1");
        }catch(err){ console.error("hugochart init error:",err); }
      });
    }

    if(document.readyState==="loading"){ document.addEventListener("DOMContentLoaded", initAll); } else { setTimeout(initAll,0); }
  }
})();
</script>
