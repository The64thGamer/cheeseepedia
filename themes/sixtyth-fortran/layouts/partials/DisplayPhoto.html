{{- /* layouts/partials/build-photo-indexes.html (robust, drop-in)
     - Always uses global `site`.
     - Ensures we always treat byPage entries as slices before appending.
     - Dedupes by RelPermalink.
     - Returns dict {byTitle, byPath, byPage, meta}.
     Usage (cached): {{ $idx := partialCached "build-photo-indexes.html" site "photos-index-v1" }}
*/ -}}

{{- $site := site -}}
{{- if not $site -}}
  {{- return (dict "byTitle" (dict) "byPath" (dict) "byPage" (dict) "meta" (dict)) -}}
{{- end -}}

{{- $photos := where $site.RegularPages "Section" "photos" -}}
{{- $byTitle := dict -}}
{{- $byPath  := dict -}}
{{- $byPage  := dict -}}
{{- $meta    := dict -}}

{{- range $p := $photos -}}
  {{- $titleKey := $p.Title -}}
  {{- $filePathKey := $p.File.Path | default "" | printf "%s" -}}

  {{- /* Determine static file existence & imageURL (try extensions) */ -}}
  {{- $fileName := $titleKey -}}
  {{- $hasFile := false -}}
  {{- if ne $fileName "" -}}
    {{- $firstTry := printf "static/photos/%s" $fileName -}}
    {{- if fileExists $firstTry -}}
      {{- $hasFile = true -}}
    {{- else -}}
      {{- $exts := slice ".jpg" ".jpeg" ".png" ".webp" ".avif" ".gif" -}}
      {{- range $e := $exts -}}
        {{- $try := printf "static/photos/%s%s" $fileName $e -}}
        {{- if fileExists $try -}}
          {{- $hasFile = true -}}
          {{- $fileName = printf "%s%s" $fileName $e -}}
          {{- break -}}
        {{- end -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}
  {{- $imageURL := cond $hasFile (printf "/photos/%s" $fileName) "/UI/File Not Found.jpg" -}}

  {{- /* store byTitle/byPath/meta */ -}}
  {{- $byTitle = merge $byTitle (dict $titleKey $p) -}}
  {{- if ne $filePathKey "" -}} {{- $byPath = merge $byPath (dict $filePathKey $p) -}} {{- end -}}
  {{- $meta = merge $meta (dict $titleKey (dict "imageURL" $imageURL "hasFile" $hasFile "fileName" $fileName)) -}}

  {{- /* Normalize .Params.pages into a simple slice of strings */ -}}
  {{- $pagesList := slice -}}
  {{- $rawPages := $p.Params.pages -}}
  {{- if $rawPages -}}
    {{- $t := printf "%T" $rawPages -}}
    {{- if in $t "string" -}}
      {{- $pagesList = slice $rawPages -}}
    {{- else if in $t "[]" -}}
      {{- range $el := $rawPages -}}
        {{- $et := printf "%T" $el -}}
        {{- if in $et "string" -}}
          {{- $pagesList = append $pagesList $el -}}
        {{- else if in $et "[]" -}}
          {{- range $inner := $el -}}
            {{- $pagesList = append $pagesList (printf "%v" $inner) -}}
          {{- end -}}
        {{- else -}}
          {{- $pagesList = append $pagesList (printf "%v" $el) -}}
        {{- end -}}
      {{- end -}}
    {{- else -}}
      {{- $pagesList = default (slice) $rawPages -}}
    {{- end -}}
  {{- end -}}

  {{- /* For each referenced wiki page, ensure byPage[key] is a slice then append if not duplicate */ -}}
  {{- range $pRef := $pagesList -}}
    {{- $key := printf "%s" $pRef -}}

    {{- /* Load raw existing entry (may be nil, a Page, or a slice) */ -}}
    {{- $existingRaw := index $byPage $key -}}

    {{- /* Build a guaranteed slice `$existing` from `$existingRaw` */ -}}
    {{- $existing := slice -}}
    {{- if $existingRaw -}}
      {{- $typeRaw := printf "%T" $existingRaw -}}
      {{- if in $typeRaw "[]" -}}
        {{- /* existingRaw is a slice — iterate and append elements to $existing */ -}}
        {{- range $i, $el := $existingRaw -}}
          {{- $existing = append $existing $el -}}
        {{- end -}}
      {{- else -}}
        {{- /* single item — append it into our slice */ -}}
        {{- $existing = append $existing $existingRaw -}}
      {{- end -}}
    {{- end -}}

    {{- /* dedupe by RelPermalink */ -}}
    {{- $already := where $existing "RelPermalink" $p.RelPermalink -}}
    {{- if eq (len $already) 0 -}}
      {{- $byPage = merge $byPage (dict $key (append $existing $p)) -}}
    {{- end -}}
  {{- end -}}
{{- end -}}

{{- return (dict "byTitle" $byTitle "byPath" $byPath "byPage" $byPage "meta" $meta) -}}
